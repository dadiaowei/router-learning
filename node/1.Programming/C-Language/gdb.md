
## 1. 查看内核调试配置信息
 
```shell
	# ulimit -a
	
		core file size          (blocks, -c) unlimited
		data seg size           (kbytes, -d) unlimited
		scheduling priority             (-e) 0
		file size               (blocks, -f) unlimited
		pending signals                 (-i) 7840
		max locked memory       (kbytes, -l) 64
		max memory size         (kbytes, -m) unlimited
		open files                      (-n) 1024
		pipe size            (512 bytes, -p) 8
		POSIX message queues     (bytes, -q) 819200
		real-time priority              (-r) 0
		stack size              (kbytes, -s) 8192
		cpu time               (seconds, -t) unlimited
		max user processes              (-u) 7840
		virtual memory          (kbytes, -v) unlimited
		file locks                      (-x) unlimited
```				
				
## 2. 设置core输出大小：不限制大小

```shell
	# ulimit -c unlimited
```

## 3. 编写源文件

```c
	#include <stdio.h>

	int main(void) {
		int *p = NULL;
		*p = 10;
		return 0;
	}
```

## 4. 编译源文件

```shell
    # gcc -g 03-test-gdb.c
		注意添加 -g 参数。
```

## 5. 运行a.out出现段错误，并在当前目录生成core文件：  core_1553045168_14260_a.out
	（因为2步骤设置了段错误输出，所以这里会自动生成core文件。）

## 6. 调试

```shell
	  # gdb ./a.out

		(gdb) core core_1553045168_14260_a.out 
		[New LWP 14260]
		Core was generated by `./a.out'.
		Program terminated with signal SIGSEGV, Segmentation fault.
		#0  0x080483fd in main () at 03-test-gdb.c:5
		5		*p = 10;
		(gdb) 

    通过gdb调试可执行文件，并载入core文件，可以找到段错误发生的位置：代码中的第5行。
```
		
## 7. 以上步骤为通过core文件和可执行文件找到段错误的位置
     如果没有core文件的话，也可以直接通过gdb调试的break命令设置断点。